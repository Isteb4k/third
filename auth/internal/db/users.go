package db

import (
	"auth/internal/entities"
	"context"
	"database/sql"
)

type users struct {
	store *sql.DB
}

type Users interface {
	Create(ctx context.Context, poll entities.User) (*entities.User, error)
	GetByID(ctx context.Context, id int) (*entities.User, error)
	DeleteByID(ctx context.Context, id int) error
}

func NewUsers(c Client) Users {
	u := users{
		store: c.getConnection(),
	}

	//_, err := u.store.Exec("DROP TABLE IF EXISTS users;")
	//if err != nil {
	//	panic(err)
	//}

	_, err := u.store.Exec(`CREATE TABLE IF NOT EXISTS users (
		id		   integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    	first_name text,
    	last_name  text
	);`)
	if err != nil {
		panic(err)
	}

	return &u
}

func (u *users) Create(ctx context.Context, user entities.User) (*entities.User, error) {
	if err := u.store.QueryRow(
		"INSERT INTO users (first_name, last_name) VALUES ($1, $2) RETURNING id",
		user.FirstName,
		user.LastName,
	).Scan(
		&user.ID,
	); err != nil {
		return nil, err
	}

	return &user, nil
}

func (u *users) DeleteByID(ctx context.Context, id int) error {
	_, err := u.store.Exec(
		"DELETE FROM users WHERE id=$1",
		id,
	)

	return err
}

func (u *users) GetByID(ctx context.Context, id int) (*entities.User, error) {
	user := &entities.User{}

	if err := u.store.QueryRow(
		"SELECT id, first_name, last_name FROM users WHERE id = $1",
		id,
	).Scan(
		&user.ID,
		&user.FirstName,
		&user.LastName,
	); err != nil {
		return nil, err
	}

	return user, nil
}
